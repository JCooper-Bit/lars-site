<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>2D Vectors - Lars Learning Series</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="generator" content="mkdocs-1.6.1, mkdocs-gitbook-1.0.7">

<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon">
<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta rel="next" href="" />
<link href="../css/style.min.css" rel="stylesheet"> 
</head>

<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input type="text" placeholder="Type to search" />
</div> <!-- end of book-search-input -->

<nav role="navigation">
<ul class="summary">
<li>
<a href=".." target="_blank" class="custom-link">Lars Learning Series</a>
</li>
<li class="divider"></li>
<li class="chapter" data-path="">
<a href="..">Home</a>
<li class="chapter" data-path="intro/">
<a href="../intro/">Intro</a>
<li class="chapter active" data-path="vec2/">
<a href="./">2D Vectors</a>
<li class="divider"></li>



</ul>

</nav>

</div> <!-- end of book-summary -->

<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="." ></a>
</h1>

</div> <!-- end of book-header -->

<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">

<section class="normal markdown-section">



<h1 id="lars-learning-series-part-1">lars Learning Series - Part 1</h1>
<h2 id="building-a-2d-vector-type-in-rust">Building a 2D Vector Type in Rust</h2>
<hr />
<h3 id="learning-goals">Learning Goals</h3>
<p>By the end of this lesson, students will:</p>
<ul>
<li>Understand how 2D vectors are represented mathematically and in code.  </li>
<li>Implement a <code>Vec2</code> struct in Rust that supports basic vector operations.  </li>
<li>Learn about traits, operator overloading, and code organization in a math-focused crate.  </li>
<li>Write unit tests to validate mathematical correctness.  </li>
</ul>
<hr />
<h2 id="background-what-is-a-vector">Background: What Is a Vector?</h2>
<p>As you hopefully know from school, a <strong>vector</strong> is a quantity that has both <strong>magnitude</strong> (length) and <strong>direction</strong>. If not, I will give you a whistlestop tour, or you can read an introductory article <a href="https://www.mathsisfun.com/algebra/vectors.html">here</a>.</p>
<p>In 2D space, we have multiple ways to notate vectors, the main one I will use is "Column Notation", which shows a vector as:</p>
<p><img alt="\mathbf v = \begin{bmatrix} x \ y \ \end{bmatrix}" src="../equations/vec2/Vector_definition.png" /></p>
<p>Another common way to represent vectors is using Unit Vectors and Components.</p>
<h3 id="unit-vectors">Unit Vectors</h3>
<p><strong>Unit</strong> vectors are vectors that has a magnitude of 1 in a specific direction. for example:</p>
<p><img alt="\hat x = \begin{bmatrix} 1 \ 0 \ \end{bmatrix}" src="../equations/vec2/hat_definition.png" /></p>
<p>You will often see unit vectors denoted with a hat symbol (^) above the vector name.
Additionally, you may see the unit vector for the x direction written as <img alt="\hat i" src="../equations/general/i_hat.png" /> and for the y direction as <img alt="\hat j" src="../equations/general/j_hat.png" />.</p>
<p>Therefore, to express a vector with x-component 3 and y-component 4, with unit vectors, we can write:</p>
<p><img alt="\mathbf v = 3 \hat i + 4 \hat j" src="../equations/vec2/vector_with_unit_vectors.png" /></p>
<h3 id="magnitude">Magnitude</h3>
<p><img alt="Diagram showing vector magnitude" src="../images/vectordecomp.webp" /></p>
<p><strong>Magnitude</strong> (or length) of a vector is the distance from the origin to the point defined by the vector. As you should see from the diagram above, it is calculated using the Pythagorean theorem:</p>
<p><img alt="|\mathbf v| = \sqrt{x^2 + y^2}" src="../equations/vec2/magnitude_definition.png" /></p>
<p>The notation for a vector <img alt="v" src="../equations/general/v.png" />'s magnitude is <img alt="|\mathbf v|" src="../equations/general/abs_v.png" />.</p>
<h3 id="vector-addition-and-subtraction">Vector Addition and Subtraction</h3>
<p>Vectors can be added and subtracted component-wise. For example, given two vectors:</p>
<p><img alt="\mathbf a = \begin{bmatrix} a_x \ a_y \ \end{bmatrix}" src="../equations/vec2/vector_a_definition.png" /></p>
<p><img alt="\mathbf b = \begin{bmatrix} b_x \ b_y \ \end{bmatrix}" src="../equations/vec2/vector_b_definition.png" /></p>
<p>The addition and subtraction of these vectors is defined as:</p>
<p><img alt="\mathbf a + \mathbf b = \begin{bmatrix} a_x + b_x \ a_y + b_y \ \end{bmatrix}" src="../equations/vec2/vector_addition.png" /></p>
<p><img alt="\mathbf a - \mathbf b = \begin{bmatrix} a_x - b_x \ a_y - b_y \ \end{bmatrix}" src="../equations/vec2/vector_subtraction.png" /></p>
<h3 id="scalar-multiplication-and-division">Scalar Multiplication and Division</h3>
<p>Vectors can be multiplied or divided by a scalar (a single number) by multiplying or dividing each component of the vector by that scalar. For example, given a vector:</p>
<p><img alt="\mathbf a = \begin{bmatrix} x \ y \ \end{bmatrix}" src="../equations/vec2/vector_a_definition.png" /></p>
<p>The scalar multiplication and division of this vector by a scalar k is defined as:</p>
<p><img alt="k \times \mathbf a = \begin{bmatrix} k \times x \ k \times y \ \end{bmatrix}" src="../equations/vec2/scalar_multiplication.png" /></p>
<p><img alt="\frac{\mathbf a}{k} = \begin{bmatrix} \frac{x}{k} \ \frac{y}{k} \ \end{bmatrix}" src="../equations/vec2/scalar_division.png" /></p>
<h3 id="the-dot-product">The Dot Product</h3>
<p>The dot product is a method for multiplying 2 vectors, it is notated mathematically as follows:</p>
<p><img alt="\mathbf a \cdot \mathbf b" src="../equations/vec2/adotb.png" /></p>
<p>There are 2 methods to calculate the dot product</p>
<p>The first method:</p>
<p><img alt="\mathbf a \cdot \mathbf b = |\mathbf a | \times |\mathbf b| \times cos(\theta)" src="../equations/vec2/dot_product_1.png" /></p>
<p><img alt="|\mathbf a | \, is \, the \, magnitude \, of  \, \mathbf a \" src="../equations/vec2/dot_product_1_1.png" /></p>
<p><img alt="|\mathbf b | \, is \, the \, magnitude \, of  \, \mathbf b \" src="../equations/vec2/dot_product_1_2.png" /></p>
<p><img alt="\theta \, is \, the \, angle \, between \, \mathbf a \, and \, \mathbf b" src="../equations/vec2/dot_product_1_3.png" /></p>
<p>The second method:</p>
<p><img alt="\mathbf a \cdot \mathbf b = (\mathbf a_x \times \mathbf b_x) + (\mathbf a_y \times \mathbf b_y)" src="../equations/vec2/dot_product_2.png" /></p>
<p>Where <img alt="\mathbf a_x" src="../equations/general/a_x.png" /> and <img alt="\mathbf a_y" src="../equations/general/a_y.png" /> are the x and y components of vector a respectively, and the same applies to vector b.</p>
<p>Vectors are foundational in:
- Geometry (lines, points, and normals)<br />
- Physics (velocity, force, acceleration and pretty much everything else!)<br />
- Computer graphics (movement, transformations)<br />
- Game development (positions, rotations, collision detection)</p>
<p>Let us now take our first step towards creating a 2D vector struct in Rust!</p>
<hr />
<h2 id="task-1-defining-a-2d-vector-type">Task 1: Defining a 2D Vector Type</h2>
<p>First off, we need to create a Rust struct called <code>Vec2</code> to represent a 2D vector.
- It should contain <code>(x,y)</code> variables
- You should <a href="https://doc.rust-lang.org/rust-by-example/trait/derive.html">Derive</a> common traits such as <code>Clone</code>, <code>Copy</code>, <code>Debug</code>, <code>PartialEq</code> and <code>Constructor</code>
- Finally, you should define a few useful common constant vectors such as <code>ZERO</code>, <code>ONE</code> and <strong>unit</strong> vectors for the x and y directions.</p>
<p>This sets the foundation for all vector operations.</p>
<details>
<summary>Solution</summary>


<pre><code class="language-rust">#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Constructor)]
pub struct Vec2 {
pub x: f64,
pub y: f64,
}


impl Vec2 {
pub const ZERO: Vec2 = Vec2 { x: 0.0, y: 0.0 };
pub const ONE: Vec2 = Vec2 { x: 1.0, y: 1.0 };
pub const UNIT_X: Vec2 = Vec2 { x: 1.0, y: 0.0 };
pub const UNIT_Y: Vec2 = Vec2 { x: 0.0, y: 1.0 };
}
</code></pre>

</details>

<hr />
<h2 id="task-2-computing-magnitude-vector-length">Task 2: Computing Magnitude (Vector Length)</h2>
<p>Using the Pythagorean theorem, implement a method on <code>Vec2</code> to compute the magnitude (length) of the vector.</p>
<details>
<summary>Solution</summary>


<pre><code class="language-rust">impl Vec2 {
    pub fn mag(&amp;self) -&gt; f64 {
        (self.x * self.x + self.y * self.y).sqrt()
    }
}
</code></pre>

</details>

<hr />
<h2 id="task-3-vector-arithmetic">Task 3: Vector Arithmetic</h2>
<p>Using rusts operator overloading capabilities, implement addition and subtraction for <code>Vec2</code> so that you can add and subtract vectors using the <code>+</code> and <code>-</code> operators.</p>
<p>I would recommend using the <a href="https://crates.io/crates/derive_more">derive_more</a> crate to make this easier.</p>
<details>
<summary>Solution</summary>


Using derive_more for operator overloading

<pre><code class="language-rust">use derive_more::{Add, Sub};

#[derive(Add, Sub, Div, Mul, Neg, Clone, Copy, Debug, PartialEq, PartialOrd, Constructor)] // The same as Task 1 but withAdd and Sub traits
pub struct Vec2 {
    pub x: f64,
    pub y: f64,
}
</code></pre>

Manually implementing Add and Sub traits if not using derive_more

<pre><code class="language-rust">
impl std::ops::Add for Vec2 {
    type Output = Vec2;
    fn add(self, other: Vec2) -&gt; Vec2 {
        Vec2 {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}
impl std::ops::Sub for Vec2 {
    type Output = Vec2;
    fn sub(self, other: Vec2) -&gt; Vec2 {
        Vec2 {
            x: self.x - other.x,
            y: self.y - other.y,
        }
    }
}
</code></pre>

</details>

<hr />
<h2 id="task-4-the-dot-product">Task 4: The Dot Product</h2>
<p>Implement a method on <code>Vec2</code> to compute the dot product between two vectors as we defined earlier. I recommend implementing this as a method called <code>dot</code> that takes &amp;self and another <code>Vec2</code> as an argument and returns a <code>f64</code>.</p>
<details>
<summary>Solution</summary>


<pre><code class="language-rust">    pub fn dot(&amp;self, other: &amp;Vec2) -&gt; f64 {
        (self.x * other.x) + (self.y * other.y)
    }
</code></pre>


</details>
<hr />
<h2 id="task-5-component-mapping">Task 5: Component Mapping</h2>
<p>Implement a method on <code>Vec2</code> called <code>map</code> that takes a closure as an argument. This closure should take a single <code>f64</code> and return a <code>f64</code>. The <code>map</code> method should apply this closure to both the x and y components of the vector and return a new <code>Vec2</code> with the results.</p>
<p>Mathematically speaking, we are applying a function "f" to each component of the vector</p>
<details>
<summary>Solution</summary>


<pre><code class="language-rust">    pub fn map&lt;F&gt;(&amp;self, f: F) -&gt; Vec2
    where
        F: Fn(f64) -&gt; f64,
    {
        let fx = f(self.x);
        let fy = f(self.y);
        Vec2 { x: fx, y: fy }
    }
</code></pre>

</details>

<hr />
<h2 id="task-6-normalizing-a-vector">Task 6: Normalizing a Vector</h2>
<p>Normalizing a vector means scaling it to have a magnitude of 1 while maintaining its direction. Implement a method on <code>Vec2</code> called <code>normalize</code> that returns a new <code>Vec2</code> that is the normalized version of the original vector.</p>
<p>The map function from Task 5 may be useful here.</p>
<details>
<summary>Solution</summary>


<pre><code class="language-rust">     pub fn normalize(&amp;self) -&gt; Vec2 {
        let m = self.mag();
        if m == 0.0 {
            return Vec2::ZERO; // or handle zero-length vector case as needed
        }
        self.map(|i| i / m)
}
</code></pre>


</details>

<hr />
<h2 id="task-7-scalar-multiplication-and-division">Task 7: Scalar Multiplication and Division</h2>
<p>Implement scalar multiplication and division for <code>Vec2</code> so that you can multiply and divide a vector by a scalar using the <code>*</code> and <code>/</code> operators.
You can use the <a href="https://crates.io/crates/derive_more">derive_more</a> crate again to make this easier.</p>
<details>
<summary>Solution</summary>

Using derive_more for operator overloading

<pre><code class="language-rust">use derive_more::{Mul, Div, Add, Sub};

#[derive(Add, Sub, Div, Mul, Clone, Copy, Debug, PartialEq, PartialOrd, Constructor)] // The same as Task 1 and 3 but with Mul and Div traits
pub struct Vec2 {
    pub x: f64,
    pub y: f64
}
</code></pre>

Manually implementing Mul and Div traits if not using derive_more

<pre><code class="language-rust">impl std::ops::Mul&lt;f64&gt; for Vec2 {
    type Output = Vec2;
    fn mul(self, scalar: f64) -&gt; Vec2 {
        Vec2 {
            x: self.x * scalar,
            y: self.y * scalar,
        }
    }
}
impl std::ops::Div&lt;f64&gt; for Vec2 {
    type Output = Vec2;
    fn div(self, scalar: f64) -&gt; Vec2 {
        Vec2 {
            x: self.x / scalar,
            y: self.y / scalar,
        }
    }
}
</code></pre>

</details>

<hr />
<h2 id="task-8-using-vec2-as-a-point">Task 8: Using Vec2 as a Point</h2>
<p>In many applications, 2D vectors are used to represent points in space. We should implement a method on <code>Vec2</code> called <code>dist</code> that takes another <code>Vec2</code> as an argument and returns the distance between the two points represented by the vectors.</p>
<p>Perhaps we could also add an alias type for <code>Point2</code> that is just a <code>Vec2</code> to make the intent clearer when using it as a point.</p>
<details>
<summary>Solution</summary>


<pre><code class="language-rust">    pub fn dist(&amp;self, other: &amp;Point2D) -&gt; f64 {
        (*self - *other).mag().abs()
    }
</code></pre>



<pre><code class="language-rust">pub type Point2D = Vec2;
</code></pre>


</details>

<hr />
<h2 id="task-9-testing-and-validation">Task 9: Testing and Validation</h2>
<p>Write <a href="https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html">unit tests</a> for all the methods and operator overloads you have implemented for <code>Vec2</code>. Ensure that your tests cover various cases, including edge cases like zero-length vectors.</p>
<details>
<summary>Solution</summary>


<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_add() {
        let v1 = Vec2::ZERO;
        let v2 = Vec2::ONE;
        assert_eq!(v1 + v2, Vec2::ONE);
    }

    #[test]
    fn test_sub() {
        let v1 = Vec2::new(5.0, 7.0);
        let v2 = Vec2::new(2.0, 3.0);
        assert_eq!(v1 - v2, Vec2::new(3.0, 4.0));
    }

    #[test]
    fn test_mag() {
        let v = Vec2::new(3.0, 4.0);
        assert_eq!(v.mag(), 5.0);
    }


    #[test]
    fn test_dot() {
        let a = Vec2::new(1.0, 2.0);
        let b = Vec2::new(3.0, 4.0);
        assert_eq!(a.dot(&amp;b), 11.0);
    }

    #[test]
    fn test_map() {
        let v = Vec2::new(1.0, 2.0);
        let mapped = v.map(|x| x * 2.0);
        assert_eq!(mapped, Vec2::new(2.0, 4.0));
    }

    #[test]
    fn test_normalize() {
        let v = Vec2::new(3.0, 4.0);
        let n = v.normalize();
        assert!((n.mag() - 1.0).abs() &lt; 1e-10);
    }

    #[test]
    fn test_scalar_mul() {
        let v = Vec2::new(1.0, 2.0);
        assert_eq!(2.0 * v, Vec2::new(2.0, 4.0));
    }

    #[test]
    fn test_scalar_div() {
        let v = Vec2::new(2.0, 4.0);
        assert_eq!(v / 2.0, Vec2::new(1.0, 2.0));
    }

    #[test]
    fn test_dist() {
        let a = Point2D::new(1.0, 2.0);
        let b = Point2D::new(1.0, 0.0);
        assert_eq!(a.dist(&amp;b), 2.0);
    }

    #[test]
    fn test_zero_length_normalize() {
        let v = Vec2::ZERO;
        let n = v.normalize();
        assert_eq!(n, Vec2::ZERO); // or however you choose to handle this case
    }

    #[test]
    fn test_dot_perpendicular() {
        let a = Vec2::UNIT_X;
        let b = Vec2::UNIT_Y;
        assert_eq!(a.dot(&amp;b), 0.0);
    }

// You can add more tests as needed, such as ones for commutativity, associativity, etc.
}
</code></pre>

</details>

<hr />
<h2 id="conclusion-and-next-steps">Conclusion and Next Steps</h2>
<p>Congratulations! You have successfully implemented a basic 2D vector type in Rust with essential operations and tests. This <code>Vec2</code> struct can now serve as a foundation for more complex mathematical operations and applications in graphics, physics, and game development.</p>
<p>As next steps, consider exploring:
- Implementing additional vector operations such as the 2D cross product, angle between vectors, and projection.
- Extending the <code>Vec2</code> struct to support more advanced features like interpolation (lerp)</p>
<p>In the next part of this series, we will build upon this foundation to create a 3D vector type, improve our 2D vector slightly and explore more complex mathematical concepts.</p>
<p>The code and ideas for this series is based on my <strong>lars</strong> math crate, which you can find on <a href="https://github.com/JCooper-Bit/lars">GitHub</a></p>
<hr />
<h3 id="about-the-author">About the Author</h3>
<pre><code class="language-text">     ___  _______  __   __  _______  _______  _______ 
    |   ||   _   ||  | |  ||       ||       ||       |
    |   ||  |_|  ||  |_|  ||       ||    ___||    ___|
    |   ||       ||       ||       ||   |___ |   |___ 
 ___|   ||       ||_     _||      _||    ___||    ___|
|       ||   _   |  |   |  |     |_ |   |___ |   |___ 
|_______||__| |__|  |___|  |_______||_______||_______|
</code></pre>
<p><strong>J. Cooper</strong> (JayCee) is a software developer, Maths enthusiast and musician based in the UK. They are the creator and maintainer of the lars crate and they have various other projects in progress</p>
<ul>
<li><strong>GitHub</strong>: <a href="https://github.com/JCooper-Bit">@JCooper-Bit</a></li>
<li><strong>Project Repo</strong>: <a href="https://github.com/JCooper-Bit/lars">lars on GitHub</a></li>
</ul>
<p><em>This article was published on October 29, 2025 with mkdocs.</em></p>


</section>

</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->

</div> <!-- end of body-inner -->

</div> <!-- end of book-body -->
<script src="../js/main.js"></script>
<script src="../search/main.js"></script>
<script src="../js/gitbook.min.js"></script>
<script src="../js/theme.min.js"></script>
</body>
</html>