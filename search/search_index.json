{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Linear Algebra from Scratch, A Guided Series Welcome to the companion guides for the lars crate. Alongside developing the crate itself, this series of articles is designed to help you build your own linear algebra functionality from the ground up. Each guide focuses on a small, well-defined task so you can learn and implement concepts step by step. The idea is to make the process approachable, modular, and transferable whether you want to follow the full series or just complete a few select parts. If you only need a 2D vector type, for example, you can complete the vector-related tasks and stop there. If you want to extend into 3D space or matrix transformations, you can build on top of what you\u2019ve already written. Each guide includes: - Mathematical background and conceptual explanations - Step-by-step implementation tasks - Full Rust code examples and solutions - Notes on extending or adapting the ideas further Although the examples are written in Rust, the core concepts can be adapted to any language with relative ease. Guides Introduction and Setup An overview of the project\u2019s structure, environment setup, and what to expect from the series. Read it here: \u2192 2D Vector Guide Implement a simple two-dimensional vector type, including construction, arithmetic operations, scaling, dot products, and normalization. Read it here: \u2192 3D Vector Guide (coming soon) Extend your 2D implementation into 3D space, introducing concepts such as the cross product and vector magnitude. Matrix Guide (coming soon) Build a foundation for matrix operations, transformations, and composition. Practical Applications (planned) Apply your implementations in areas like computer graphics, physics simulations, or data transformations. Modularity and Design Philosophy Each guide is written to be self-contained. You can treat them as individual learning modules or as chapters in a longer course. The goal is to make each piece useful on its own while still contributing to a larger, cohesive system. This approach mirrors how the lars crate itself is structured: small, reusable components that can stand alone or combine to form a complete linear algebra library. Contributing and Next Steps The guides are a work in progress and will continue to grow alongside the crate. Contributions, feedback, and suggestions are welcome. You can find the project on GitHub here: https://github.com/JCooper-Bit/lars These guides are written to teach by doing. Work through them in order, or pick the pieces you need, and you\u2019ll have a solid understanding of the principles behind linear algebra, and the tools to implement them yourself. About the Author ___ _______ __ __ _______ _______ _______ | || _ || | | || || || | | || |_| || |_| || || ___|| ___| | || || || || |___ | |___ ___| || ||_ _|| _|| ___|| ___| | || _ | | | | |_ | |___ | |___ |_______||__| |__| |___| |_______||_______||_______| J. Cooper (JayCee) is a software developer, Maths enthusiast and musician based in the UK. They are the creator and maintainer of the lars crate and they have various other projects in progress GitHub : @JCooper-Bit Project Repo : lars on GitHub This article was published on October 29, 2025.","title":"Home"},{"location":"#linear-algebra-from-scratch-a-guided-series","text":"Welcome to the companion guides for the lars crate. Alongside developing the crate itself, this series of articles is designed to help you build your own linear algebra functionality from the ground up. Each guide focuses on a small, well-defined task so you can learn and implement concepts step by step. The idea is to make the process approachable, modular, and transferable whether you want to follow the full series or just complete a few select parts. If you only need a 2D vector type, for example, you can complete the vector-related tasks and stop there. If you want to extend into 3D space or matrix transformations, you can build on top of what you\u2019ve already written. Each guide includes: - Mathematical background and conceptual explanations - Step-by-step implementation tasks - Full Rust code examples and solutions - Notes on extending or adapting the ideas further Although the examples are written in Rust, the core concepts can be adapted to any language with relative ease.","title":"Linear Algebra from Scratch, A Guided Series"},{"location":"#guides","text":"Introduction and Setup An overview of the project\u2019s structure, environment setup, and what to expect from the series. Read it here: \u2192 2D Vector Guide Implement a simple two-dimensional vector type, including construction, arithmetic operations, scaling, dot products, and normalization. Read it here: \u2192 3D Vector Guide (coming soon) Extend your 2D implementation into 3D space, introducing concepts such as the cross product and vector magnitude. Matrix Guide (coming soon) Build a foundation for matrix operations, transformations, and composition. Practical Applications (planned) Apply your implementations in areas like computer graphics, physics simulations, or data transformations.","title":"Guides"},{"location":"#modularity-and-design-philosophy","text":"Each guide is written to be self-contained. You can treat them as individual learning modules or as chapters in a longer course. The goal is to make each piece useful on its own while still contributing to a larger, cohesive system. This approach mirrors how the lars crate itself is structured: small, reusable components that can stand alone or combine to form a complete linear algebra library.","title":"Modularity and Design Philosophy"},{"location":"#contributing-and-next-steps","text":"The guides are a work in progress and will continue to grow alongside the crate. Contributions, feedback, and suggestions are welcome. You can find the project on GitHub here: https://github.com/JCooper-Bit/lars These guides are written to teach by doing. Work through them in order, or pick the pieces you need, and you\u2019ll have a solid understanding of the principles behind linear algebra, and the tools to implement them yourself.","title":"Contributing and Next Steps"},{"location":"#about-the-author","text":"___ _______ __ __ _______ _______ _______ | || _ || | | || || || | | || |_| || |_| || || ___|| ___| | || || || || |___ | |___ ___| || ||_ _|| _|| ___|| ___| | || _ | | | | |_ | |___ | |___ |_______||__| |__| |___| |_______||_______||_______| J. Cooper (JayCee) is a software developer, Maths enthusiast and musician based in the UK. They are the creator and maintainer of the lars crate and they have various other projects in progress GitHub : @JCooper-Bit Project Repo : lars on GitHub This article was published on October 29, 2025.","title":"About the Author"},{"location":"intro/","text":"Introduction and Setup This series is written to guide you through building your own linear algebra functionality from scratch. Each section of the series focuses on a small, contained piece of functionality. By the end, you\u2019ll have the foundation of a lightweight, modular linear algebra library that you can adapt for your own projects. You\u2019ll also gain a better understanding of the mathematics behind it. The examples are written in Rust , but the concepts are language-agnostic. If you\u2019re comfortable in another language, you can follow along just as easily. What You\u2019ll Need Before getting started, make sure you have the following: A recent version of Rust installed You can check with: bash rustc --version If it\u2019s not installed, visit https://rustup.rs to set it up. A text editor or IDE that supports Rust VS Code with the rust-analyzer extension is a good option. Basic familiarity with programming concepts and a little comfort with Rust syntax. You don\u2019t need to be an expert \u2014 we\u2019ll go step by step. Project Setup Create a new Rust project to follow along: cargo new linear_algebra_from_scratch cd linear_algebra_from_scratch This will generate a new folder with a basic Cargo.toml and src/main.rs . You can either implement everything directly in main.rs or create separate modules as the project grows. For example: src/ \u251c\u2500\u2500 main.rs \u2514\u2500\u2500 math/ \u251c\u2500\u2500 vec2.rs \u251c\u2500\u2500 vec3.rs \u2514\u2500\u2500 matrix.rs We\u2019ll expand on this structure as we move through the guides. How to Follow the Series Each guide introduces one concept at a time: starting simple and building complexity gradually. You\u2019ll find three main sections in each: Concepts/Mathematical Background : an explanation of the underlying math and how it\u2019s represented programmatically. Implementation : a series of tasks to write the code yourself. Solutions : a complete set of solutions showing one way to implement the concept. You\u2019re encouraged to write and test your own code before checking the solution. There\u2019s no single \u201cright\u201d way to implement these ideas, and exploring different approaches is part of the learning process. Next Steps When you\u2019re ready, continue to the first real task: implementing a 2D vector type. This will cover construction, basic arithmetic, and a few common operations used throughout linear algebra. Continue to the next guide: 2D Vector Guide \u2192 About the Author ___ _______ __ __ _______ _______ _______ | || _ || | | || || || | | || |_| || |_| || || ___|| ___| | || || || || |___ | |___ ___| || ||_ _|| _|| ___|| ___| | || _ | | | | |_ | |___ | |___ |_______||__| |__| |___| |_______||_______||_______| J. Cooper (JayCee) is a software developer, Maths enthusiast and musician based in the UK. They are the creator and maintainer of the lars crate and they have various other projects in progress GitHub : @JCooper-Bit Project Repo : lars on GitHub This article was published on October 29, 2025.","title":"Intro"},{"location":"intro/#introduction-and-setup","text":"This series is written to guide you through building your own linear algebra functionality from scratch. Each section of the series focuses on a small, contained piece of functionality. By the end, you\u2019ll have the foundation of a lightweight, modular linear algebra library that you can adapt for your own projects. You\u2019ll also gain a better understanding of the mathematics behind it. The examples are written in Rust , but the concepts are language-agnostic. If you\u2019re comfortable in another language, you can follow along just as easily.","title":"Introduction and Setup"},{"location":"intro/#what-youll-need","text":"Before getting started, make sure you have the following: A recent version of Rust installed You can check with: bash rustc --version If it\u2019s not installed, visit https://rustup.rs to set it up. A text editor or IDE that supports Rust VS Code with the rust-analyzer extension is a good option. Basic familiarity with programming concepts and a little comfort with Rust syntax. You don\u2019t need to be an expert \u2014 we\u2019ll go step by step.","title":"What You\u2019ll Need"},{"location":"intro/#project-setup","text":"Create a new Rust project to follow along: cargo new linear_algebra_from_scratch cd linear_algebra_from_scratch This will generate a new folder with a basic Cargo.toml and src/main.rs . You can either implement everything directly in main.rs or create separate modules as the project grows. For example: src/ \u251c\u2500\u2500 main.rs \u2514\u2500\u2500 math/ \u251c\u2500\u2500 vec2.rs \u251c\u2500\u2500 vec3.rs \u2514\u2500\u2500 matrix.rs We\u2019ll expand on this structure as we move through the guides.","title":"Project Setup"},{"location":"intro/#how-to-follow-the-series","text":"Each guide introduces one concept at a time: starting simple and building complexity gradually. You\u2019ll find three main sections in each: Concepts/Mathematical Background : an explanation of the underlying math and how it\u2019s represented programmatically. Implementation : a series of tasks to write the code yourself. Solutions : a complete set of solutions showing one way to implement the concept. You\u2019re encouraged to write and test your own code before checking the solution. There\u2019s no single \u201cright\u201d way to implement these ideas, and exploring different approaches is part of the learning process.","title":"How to Follow the Series"},{"location":"intro/#next-steps","text":"When you\u2019re ready, continue to the first real task: implementing a 2D vector type. This will cover construction, basic arithmetic, and a few common operations used throughout linear algebra. Continue to the next guide: 2D Vector Guide \u2192","title":"Next Steps"},{"location":"intro/#about-the-author","text":"___ _______ __ __ _______ _______ _______ | || _ || | | || || || | | || |_| || |_| || || ___|| ___| | || || || || |___ | |___ ___| || ||_ _|| _|| ___|| ___| | || _ | | | | |_ | |___ | |___ |_______||__| |__| |___| |_______||_______||_______| J. Cooper (JayCee) is a software developer, Maths enthusiast and musician based in the UK. They are the creator and maintainer of the lars crate and they have various other projects in progress GitHub : @JCooper-Bit Project Repo : lars on GitHub This article was published on October 29, 2025.","title":"About the Author"},{"location":"vec2/","text":"lars Learning Series - Part 1 Building a 2D Vector Type in Rust Learning Goals By the end of this lesson, students will: Understand how 2D vectors are represented mathematically and in code. Implement a Vec2 struct in Rust that supports basic vector operations. Learn about traits, operator overloading, and code organization in a math-focused crate. Write unit tests to validate mathematical correctness. Background: What Is a Vector? As you hopefully know from school, a vector is a quantity that has both magnitude (length) and direction . If not, I will give you a whistlestop tour, or you can read an introductory article here . In 2D space, we have multiple ways to notate vectors, the main one I will use is \"Column Notation\", which shows a vector as: Another common way to represent vectors is using Unit Vectors and Components. Unit Vectors Unit vectors are vectors that has a magnitude of 1 in a specific direction. for example: You will often see unit vectors denoted with a hat symbol (^) above the vector name. Additionally, you may see the unit vector for the x direction written as and for the y direction as . Therefore, to express a vector with x-component 3 and y-component 4, with unit vectors, we can write: Magnitude Magnitude (or length) of a vector is the distance from the origin to the point defined by the vector. As you should see from the diagram above, it is calculated using the Pythagorean theorem: The notation for a vector 's magnitude is . Vector Addition and Subtraction Vectors can be added and subtracted component-wise. For example, given two vectors: The addition and subtraction of these vectors is defined as: Scalar Multiplication and Division Vectors can be multiplied or divided by a scalar (a single number) by multiplying or dividing each component of the vector by that scalar. For example, given a vector: The scalar multiplication and division of this vector by a scalar k is defined as: The Dot Product The dot product is a method for multiplying 2 vectors, it is notated mathematically as follows: There are 2 methods to calculate the dot product The first method: The second method: Where and are the x and y components of vector a respectively, and the same applies to vector b. Vectors are foundational in: - Geometry (lines, points, and normals) - Physics (velocity, force, acceleration and pretty much everything else!) - Computer graphics (movement, transformations) - Game development (positions, rotations, collision detection) Let us now take our first step towards creating a 2D vector struct in Rust! Task 1: Defining a 2D Vector Type First off, we need to create a Rust struct called Vec2 to represent a 2D vector. - It should contain (x,y) variables - You should Derive common traits such as Clone , Copy , Debug , PartialEq and Constructor - Finally, you should define a few useful common constant vectors such as ZERO , ONE and unit vectors for the x and y directions. This sets the foundation for all vector operations. Solution #[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Constructor)] pub struct Vec2 { pub x: f64, pub y: f64, } impl Vec2 { pub const ZERO: Vec2 = Vec2 { x: 0.0, y: 0.0 }; pub const ONE: Vec2 = Vec2 { x: 1.0, y: 1.0 }; pub const UNIT_X: Vec2 = Vec2 { x: 1.0, y: 0.0 }; pub const UNIT_Y: Vec2 = Vec2 { x: 0.0, y: 1.0 }; } Task 2: Computing Magnitude (Vector Length) Using the Pythagorean theorem, implement a method on Vec2 to compute the magnitude (length) of the vector. Solution impl Vec2 { pub fn mag(&self) -> f64 { (self.x * self.x + self.y * self.y).sqrt() } } Task 3: Vector Arithmetic Using rusts operator overloading capabilities, implement addition and subtraction for Vec2 so that you can add and subtract vectors using the + and - operators. I would recommend using the derive_more crate to make this easier. Solution Using derive_more for operator overloading use derive_more::{Add, Sub}; #[derive(Add, Sub, Div, Mul, Neg, Clone, Copy, Debug, PartialEq, PartialOrd, Constructor)] // The same as Task 1 but withAdd and Sub traits pub struct Vec2 { pub x: f64, pub y: f64, } Manually implementing Add and Sub traits if not using derive_more impl std::ops::Add for Vec2 { type Output = Vec2; fn add(self, other: Vec2) -> Vec2 { Vec2 { x: self.x + other.x, y: self.y + other.y, } } } impl std::ops::Sub for Vec2 { type Output = Vec2; fn sub(self, other: Vec2) -> Vec2 { Vec2 { x: self.x - other.x, y: self.y - other.y, } } } Task 4: The Dot Product Implement a method on Vec2 to compute the dot product between two vectors as we defined earlier. I recommend implementing this as a method called dot that takes &self and another Vec2 as an argument and returns a f64 . Solution pub fn dot(&self, other: &Vec2) -> f64 { (self.x * other.x) + (self.y * other.y) } Task 5: Component Mapping Implement a method on Vec2 called map that takes a closure as an argument. This closure should take a single f64 and return a f64 . The map method should apply this closure to both the x and y components of the vector and return a new Vec2 with the results. Mathematically speaking, we are applying a function \"f\" to each component of the vector Solution pub fn map<F>(&self, f: F) -> Vec2 where F: Fn(f64) -> f64, { let fx = f(self.x); let fy = f(self.y); Vec2 { x: fx, y: fy } } Task 6: Normalizing a Vector Normalizing a vector means scaling it to have a magnitude of 1 while maintaining its direction. Implement a method on Vec2 called normalize that returns a new Vec2 that is the normalized version of the original vector. The map function from Task 5 may be useful here. Solution pub fn normalize(&self) -> Vec2 { let m = self.mag(); if m == 0.0 { return Vec2::ZERO; // or handle zero-length vector case as needed } self.map(|i| i / m) } Task 7: Scalar Multiplication and Division Implement scalar multiplication and division for Vec2 so that you can multiply and divide a vector by a scalar using the * and / operators. You can use the derive_more crate again to make this easier. Solution Using derive_more for operator overloading use derive_more::{Mul, Div, Add, Sub}; #[derive(Add, Sub, Div, Mul, Clone, Copy, Debug, PartialEq, PartialOrd, Constructor)] // The same as Task 1 and 3 but with Mul and Div traits pub struct Vec2 { pub x: f64, pub y: f64 } Manually implementing Mul and Div traits if not using derive_more impl std::ops::Mul<f64> for Vec2 { type Output = Vec2; fn mul(self, scalar: f64) -> Vec2 { Vec2 { x: self.x * scalar, y: self.y * scalar, } } } impl std::ops::Div<f64> for Vec2 { type Output = Vec2; fn div(self, scalar: f64) -> Vec2 { Vec2 { x: self.x / scalar, y: self.y / scalar, } } } Task 8: Using Vec2 as a Point In many applications, 2D vectors are used to represent points in space. We should implement a method on Vec2 called dist that takes another Vec2 as an argument and returns the distance between the two points represented by the vectors. Perhaps we could also add an alias type for Point2 that is just a Vec2 to make the intent clearer when using it as a point. Solution pub fn dist(&self, other: &Point2D) -> f64 { (*self - *other).mag().abs() } pub type Point2D = Vec2; Task 9: Testing and Validation Write unit tests for all the methods and operator overloads you have implemented for Vec2 . Ensure that your tests cover various cases, including edge cases like zero-length vectors. Solution #[cfg(test)] mod tests { use super::*; #[test] fn test_add() { let v1 = Vec2::ZERO; let v2 = Vec2::ONE; assert_eq!(v1 + v2, Vec2::ONE); } #[test] fn test_sub() { let v1 = Vec2::new(5.0, 7.0); let v2 = Vec2::new(2.0, 3.0); assert_eq!(v1 - v2, Vec2::new(3.0, 4.0)); } #[test] fn test_mag() { let v = Vec2::new(3.0, 4.0); assert_eq!(v.mag(), 5.0); } #[test] fn test_dot() { let a = Vec2::new(1.0, 2.0); let b = Vec2::new(3.0, 4.0); assert_eq!(a.dot(&b), 11.0); } #[test] fn test_map() { let v = Vec2::new(1.0, 2.0); let mapped = v.map(|x| x * 2.0); assert_eq!(mapped, Vec2::new(2.0, 4.0)); } #[test] fn test_normalize() { let v = Vec2::new(3.0, 4.0); let n = v.normalize(); assert!((n.mag() - 1.0).abs() < 1e-10); } #[test] fn test_scalar_mul() { let v = Vec2::new(1.0, 2.0); assert_eq!(2.0 * v, Vec2::new(2.0, 4.0)); } #[test] fn test_scalar_div() { let v = Vec2::new(2.0, 4.0); assert_eq!(v / 2.0, Vec2::new(1.0, 2.0)); } #[test] fn test_dist() { let a = Point2D::new(1.0, 2.0); let b = Point2D::new(1.0, 0.0); assert_eq!(a.dist(&b), 2.0); } #[test] fn test_zero_length_normalize() { let v = Vec2::ZERO; let n = v.normalize(); assert_eq!(n, Vec2::ZERO); // or however you choose to handle this case } #[test] fn test_dot_perpendicular() { let a = Vec2::UNIT_X; let b = Vec2::UNIT_Y; assert_eq!(a.dot(&b), 0.0); } // You can add more tests as needed, such as ones for commutativity, associativity, etc. } Conclusion and Next Steps Congratulations! You have successfully implemented a basic 2D vector type in Rust with essential operations and tests. This Vec2 struct can now serve as a foundation for more complex mathematical operations and applications in graphics, physics, and game development. As next steps, consider exploring: - Implementing additional vector operations such as the 2D cross product, angle between vectors, and projection. - Extending the Vec2 struct to support more advanced features like interpolation (lerp) In the next part of this series, we will build upon this foundation to create a 3D vector type, improve our 2D vector slightly and explore more complex mathematical concepts. The code and ideas for this series is based on my lars math crate, which you can find on GitHub About the Author ___ _______ __ __ _______ _______ _______ | || _ || | | || || || | | || |_| || |_| || || ___|| ___| | || || || || |___ | |___ ___| || ||_ _|| _|| ___|| ___| | || _ | | | | |_ | |___ | |___ |_______||__| |__| |___| |_______||_______||_______| J. Cooper (JayCee) is a software developer, Maths enthusiast and musician based in the UK. They are the creator and maintainer of the lars crate and they have various other projects in progress GitHub : @JCooper-Bit Project Repo : lars on GitHub This article was published on October 29, 2025.","title":"2D Vectors"},{"location":"vec2/#lars-learning-series-part-1","text":"","title":"lars Learning Series - Part 1"},{"location":"vec2/#building-a-2d-vector-type-in-rust","text":"","title":"Building a 2D Vector Type in Rust"},{"location":"vec2/#learning-goals","text":"By the end of this lesson, students will: Understand how 2D vectors are represented mathematically and in code. Implement a Vec2 struct in Rust that supports basic vector operations. Learn about traits, operator overloading, and code organization in a math-focused crate. Write unit tests to validate mathematical correctness.","title":"Learning Goals"},{"location":"vec2/#background-what-is-a-vector","text":"As you hopefully know from school, a vector is a quantity that has both magnitude (length) and direction . If not, I will give you a whistlestop tour, or you can read an introductory article here . In 2D space, we have multiple ways to notate vectors, the main one I will use is \"Column Notation\", which shows a vector as: Another common way to represent vectors is using Unit Vectors and Components.","title":"Background: What Is a Vector?"},{"location":"vec2/#unit-vectors","text":"Unit vectors are vectors that has a magnitude of 1 in a specific direction. for example: You will often see unit vectors denoted with a hat symbol (^) above the vector name. Additionally, you may see the unit vector for the x direction written as and for the y direction as . Therefore, to express a vector with x-component 3 and y-component 4, with unit vectors, we can write:","title":"Unit Vectors"},{"location":"vec2/#magnitude","text":"Magnitude (or length) of a vector is the distance from the origin to the point defined by the vector. As you should see from the diagram above, it is calculated using the Pythagorean theorem: The notation for a vector 's magnitude is .","title":"Magnitude"},{"location":"vec2/#vector-addition-and-subtraction","text":"Vectors can be added and subtracted component-wise. For example, given two vectors: The addition and subtraction of these vectors is defined as:","title":"Vector Addition and Subtraction"},{"location":"vec2/#scalar-multiplication-and-division","text":"Vectors can be multiplied or divided by a scalar (a single number) by multiplying or dividing each component of the vector by that scalar. For example, given a vector: The scalar multiplication and division of this vector by a scalar k is defined as:","title":"Scalar Multiplication and Division"},{"location":"vec2/#the-dot-product","text":"The dot product is a method for multiplying 2 vectors, it is notated mathematically as follows: There are 2 methods to calculate the dot product The first method: The second method: Where and are the x and y components of vector a respectively, and the same applies to vector b. Vectors are foundational in: - Geometry (lines, points, and normals) - Physics (velocity, force, acceleration and pretty much everything else!) - Computer graphics (movement, transformations) - Game development (positions, rotations, collision detection) Let us now take our first step towards creating a 2D vector struct in Rust!","title":"The Dot Product"},{"location":"vec2/#task-1-defining-a-2d-vector-type","text":"First off, we need to create a Rust struct called Vec2 to represent a 2D vector. - It should contain (x,y) variables - You should Derive common traits such as Clone , Copy , Debug , PartialEq and Constructor - Finally, you should define a few useful common constant vectors such as ZERO , ONE and unit vectors for the x and y directions. This sets the foundation for all vector operations. Solution #[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Constructor)] pub struct Vec2 { pub x: f64, pub y: f64, } impl Vec2 { pub const ZERO: Vec2 = Vec2 { x: 0.0, y: 0.0 }; pub const ONE: Vec2 = Vec2 { x: 1.0, y: 1.0 }; pub const UNIT_X: Vec2 = Vec2 { x: 1.0, y: 0.0 }; pub const UNIT_Y: Vec2 = Vec2 { x: 0.0, y: 1.0 }; }","title":"Task 1: Defining a 2D Vector Type"},{"location":"vec2/#task-2-computing-magnitude-vector-length","text":"Using the Pythagorean theorem, implement a method on Vec2 to compute the magnitude (length) of the vector. Solution impl Vec2 { pub fn mag(&self) -> f64 { (self.x * self.x + self.y * self.y).sqrt() } }","title":"Task 2: Computing Magnitude (Vector Length)"},{"location":"vec2/#task-3-vector-arithmetic","text":"Using rusts operator overloading capabilities, implement addition and subtraction for Vec2 so that you can add and subtract vectors using the + and - operators. I would recommend using the derive_more crate to make this easier. Solution Using derive_more for operator overloading use derive_more::{Add, Sub}; #[derive(Add, Sub, Div, Mul, Neg, Clone, Copy, Debug, PartialEq, PartialOrd, Constructor)] // The same as Task 1 but withAdd and Sub traits pub struct Vec2 { pub x: f64, pub y: f64, } Manually implementing Add and Sub traits if not using derive_more impl std::ops::Add for Vec2 { type Output = Vec2; fn add(self, other: Vec2) -> Vec2 { Vec2 { x: self.x + other.x, y: self.y + other.y, } } } impl std::ops::Sub for Vec2 { type Output = Vec2; fn sub(self, other: Vec2) -> Vec2 { Vec2 { x: self.x - other.x, y: self.y - other.y, } } }","title":"Task 3: Vector Arithmetic"},{"location":"vec2/#task-4-the-dot-product","text":"Implement a method on Vec2 to compute the dot product between two vectors as we defined earlier. I recommend implementing this as a method called dot that takes &self and another Vec2 as an argument and returns a f64 . Solution pub fn dot(&self, other: &Vec2) -> f64 { (self.x * other.x) + (self.y * other.y) }","title":"Task 4: The Dot Product"},{"location":"vec2/#task-5-component-mapping","text":"Implement a method on Vec2 called map that takes a closure as an argument. This closure should take a single f64 and return a f64 . The map method should apply this closure to both the x and y components of the vector and return a new Vec2 with the results. Mathematically speaking, we are applying a function \"f\" to each component of the vector Solution pub fn map<F>(&self, f: F) -> Vec2 where F: Fn(f64) -> f64, { let fx = f(self.x); let fy = f(self.y); Vec2 { x: fx, y: fy } }","title":"Task 5: Component Mapping"},{"location":"vec2/#task-6-normalizing-a-vector","text":"Normalizing a vector means scaling it to have a magnitude of 1 while maintaining its direction. Implement a method on Vec2 called normalize that returns a new Vec2 that is the normalized version of the original vector. The map function from Task 5 may be useful here. Solution pub fn normalize(&self) -> Vec2 { let m = self.mag(); if m == 0.0 { return Vec2::ZERO; // or handle zero-length vector case as needed } self.map(|i| i / m) }","title":"Task 6: Normalizing a Vector"},{"location":"vec2/#task-7-scalar-multiplication-and-division","text":"Implement scalar multiplication and division for Vec2 so that you can multiply and divide a vector by a scalar using the * and / operators. You can use the derive_more crate again to make this easier. Solution Using derive_more for operator overloading use derive_more::{Mul, Div, Add, Sub}; #[derive(Add, Sub, Div, Mul, Clone, Copy, Debug, PartialEq, PartialOrd, Constructor)] // The same as Task 1 and 3 but with Mul and Div traits pub struct Vec2 { pub x: f64, pub y: f64 } Manually implementing Mul and Div traits if not using derive_more impl std::ops::Mul<f64> for Vec2 { type Output = Vec2; fn mul(self, scalar: f64) -> Vec2 { Vec2 { x: self.x * scalar, y: self.y * scalar, } } } impl std::ops::Div<f64> for Vec2 { type Output = Vec2; fn div(self, scalar: f64) -> Vec2 { Vec2 { x: self.x / scalar, y: self.y / scalar, } } }","title":"Task 7: Scalar Multiplication and Division"},{"location":"vec2/#task-8-using-vec2-as-a-point","text":"In many applications, 2D vectors are used to represent points in space. We should implement a method on Vec2 called dist that takes another Vec2 as an argument and returns the distance between the two points represented by the vectors. Perhaps we could also add an alias type for Point2 that is just a Vec2 to make the intent clearer when using it as a point. Solution pub fn dist(&self, other: &Point2D) -> f64 { (*self - *other).mag().abs() } pub type Point2D = Vec2;","title":"Task 8: Using Vec2 as a Point"},{"location":"vec2/#task-9-testing-and-validation","text":"Write unit tests for all the methods and operator overloads you have implemented for Vec2 . Ensure that your tests cover various cases, including edge cases like zero-length vectors. Solution #[cfg(test)] mod tests { use super::*; #[test] fn test_add() { let v1 = Vec2::ZERO; let v2 = Vec2::ONE; assert_eq!(v1 + v2, Vec2::ONE); } #[test] fn test_sub() { let v1 = Vec2::new(5.0, 7.0); let v2 = Vec2::new(2.0, 3.0); assert_eq!(v1 - v2, Vec2::new(3.0, 4.0)); } #[test] fn test_mag() { let v = Vec2::new(3.0, 4.0); assert_eq!(v.mag(), 5.0); } #[test] fn test_dot() { let a = Vec2::new(1.0, 2.0); let b = Vec2::new(3.0, 4.0); assert_eq!(a.dot(&b), 11.0); } #[test] fn test_map() { let v = Vec2::new(1.0, 2.0); let mapped = v.map(|x| x * 2.0); assert_eq!(mapped, Vec2::new(2.0, 4.0)); } #[test] fn test_normalize() { let v = Vec2::new(3.0, 4.0); let n = v.normalize(); assert!((n.mag() - 1.0).abs() < 1e-10); } #[test] fn test_scalar_mul() { let v = Vec2::new(1.0, 2.0); assert_eq!(2.0 * v, Vec2::new(2.0, 4.0)); } #[test] fn test_scalar_div() { let v = Vec2::new(2.0, 4.0); assert_eq!(v / 2.0, Vec2::new(1.0, 2.0)); } #[test] fn test_dist() { let a = Point2D::new(1.0, 2.0); let b = Point2D::new(1.0, 0.0); assert_eq!(a.dist(&b), 2.0); } #[test] fn test_zero_length_normalize() { let v = Vec2::ZERO; let n = v.normalize(); assert_eq!(n, Vec2::ZERO); // or however you choose to handle this case } #[test] fn test_dot_perpendicular() { let a = Vec2::UNIT_X; let b = Vec2::UNIT_Y; assert_eq!(a.dot(&b), 0.0); } // You can add more tests as needed, such as ones for commutativity, associativity, etc. }","title":"Task 9: Testing and Validation"},{"location":"vec2/#conclusion-and-next-steps","text":"Congratulations! You have successfully implemented a basic 2D vector type in Rust with essential operations and tests. This Vec2 struct can now serve as a foundation for more complex mathematical operations and applications in graphics, physics, and game development. As next steps, consider exploring: - Implementing additional vector operations such as the 2D cross product, angle between vectors, and projection. - Extending the Vec2 struct to support more advanced features like interpolation (lerp) In the next part of this series, we will build upon this foundation to create a 3D vector type, improve our 2D vector slightly and explore more complex mathematical concepts. The code and ideas for this series is based on my lars math crate, which you can find on GitHub","title":"Conclusion and Next Steps"},{"location":"vec2/#about-the-author","text":"___ _______ __ __ _______ _______ _______ | || _ || | | || || || | | || |_| || |_| || || ___|| ___| | || || || || |___ | |___ ___| || ||_ _|| _|| ___|| ___| | || _ | | | | |_ | |___ | |___ |_______||__| |__| |___| |_______||_______||_______| J. Cooper (JayCee) is a software developer, Maths enthusiast and musician based in the UK. They are the creator and maintainer of the lars crate and they have various other projects in progress GitHub : @JCooper-Bit Project Repo : lars on GitHub This article was published on October 29, 2025.","title":"About the Author"}]}